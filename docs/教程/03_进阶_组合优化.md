# 进阶教程：组合优化

本教程介绍如何使用 fincore 构建最优投资组合。

## 前置知识

- 完成 [入门教程](01_入门_策略绩效分析.md)
- 了解均值-方差优化、夏普比率的概念

## 准备多资产数据

```python
import numpy as np
import pandas as pd

np.random.seed(42)
n_days = 500
dates = pd.date_range("2020-01-01", periods=n_days, freq="B")

# 模拟 5 个资产的相关收益率
mean_returns = [0.0005, 0.0003, 0.0008, 0.0002, 0.0006]
cov_matrix = np.array([
    [0.0004, 0.0001, 0.0002, 0.00005, 0.00015],
    [0.0001, 0.0003, 0.00008, 0.0001, 0.0001],
    [0.0002, 0.00008, 0.0006, 0.0001, 0.00025],
    [0.00005, 0.0001, 0.0001, 0.0002, 0.00008],
    [0.00015, 0.0001, 0.00025, 0.00008, 0.0005],
])

raw = np.random.multivariate_normal(mean_returns, cov_matrix, n_days)
assets = ["股票_美国", "债券_美国", "股票_新兴", "债券_新兴", "大宗商品"]
returns = pd.DataFrame(raw, index=dates, columns=assets)

# 查看各资产特征
for col in returns.columns:
    ann_ret = (1 + returns[col].mean()) ** 252 - 1
    ann_vol = returns[col].std() * np.sqrt(252)
    print(f"{col:<12} 年化收益={ann_ret:.2%}  年化波动={ann_vol:.2%}  夏普={ann_ret/ann_vol:.2f}")
```

## 第 1 步：有效前沿

计算一组"在给定风险下收益最高"（或"给定收益下风险最低"）的组合：

```python
from fincore.optimization import efficient_frontier

ef = efficient_frontier(returns, n_points=30)
print(f"有效前沿: {len(ef)} 个点")
print(ef[["return", "risk"]].describe())
```

> **解读**: 有效前沿上的每个点代表一个最优组合。前沿以下的组合都是次优的。

## 第 2 步：最大夏普组合

找到风险调整收益最高的组合：

```python
from fincore.optimization import optimize

max_sharpe = optimize(returns, objective="max_sharpe")

print("=== 最大夏普组合 ===")
for asset, w in zip(assets, max_sharpe["weights"]):
    print(f"  {asset:<12} {w:.1%}")
print(f"  预期收益: {max_sharpe['return']:.2%}")
print(f"  预期风险: {max_sharpe['risk']:.2%}")
print(f"  夏普比率: {max_sharpe['sharpe']:.4f}")
```

## 第 3 步：最小方差组合

风险最低的组合（适合保守投资者）：

```python
min_var = optimize(returns, objective="min_variance")

print("=== 最小方差组合 ===")
for asset, w in zip(assets, min_var["weights"]):
    print(f"  {asset:<12} {w:.1%}")
print(f"  预期收益: {min_var['return']:.2%}")
print(f"  预期风险: {min_var['risk']:.2%}")
```

## 第 4 步：目标收益组合

指定目标收益率，最小化风险：

```python
target = optimize(returns, objective="target_return", target=0.10)

print("=== 目标收益 10% 组合 ===")
for asset, w in zip(assets, target["weights"]):
    print(f"  {asset:<12} {w:.1%}")
print(f"  预期收益: {target['return']:.2%}")
print(f"  预期风险: {target['risk']:.2%}")
```

## 第 5 步：风险平价

使每个资产对组合总风险的贡献相等：

```python
from fincore.optimization import risk_parity

rp_weights = risk_parity(returns)

print("=== 风险平价组合 ===")
for asset, w in zip(assets, rp_weights):
    print(f"  {asset:<12} {w:.1%}")

# 验证风险贡献
cov = returns.cov().values * 252
port_vol = np.sqrt(rp_weights @ cov @ rp_weights)
marginal = cov @ rp_weights
risk_contrib = rp_weights * marginal / port_vol
print(f"\n风险贡献（应接近相等）:")
for asset, rc in zip(assets, risk_contrib):
    print(f"  {asset:<12} {rc:.4f}")
```

> **优势**: 风险平价不需要预测收益率，仅基于协方差矩阵，更加稳健

## 第 6 步：组合对比

```python
# 等权组合作为基准
eq_w = np.ones(5) / 5
eq_ret = (returns.mean() * 252) @ eq_w
eq_risk = np.sqrt(eq_w @ (returns.cov().values * 252) @ eq_w)

print(f"\n{'组合':<15} {'收益':<10} {'风险':<10} {'夏普':<10}")
print("-" * 45)
print(f"{'等权':<15} {eq_ret:<10.2%} {eq_risk:<10.2%} {eq_ret/eq_risk:<10.2f}")
print(f"{'最大夏普':<15} {max_sharpe['return']:<10.2%} {max_sharpe['risk']:<10.2%} {max_sharpe['sharpe']:<10.2f}")
print(f"{'最小方差':<15} {min_var['return']:<10.2%} {min_var['risk']:<10.2%} {min_var['return']/min_var['risk']:<10.2f}")
```

## 实践建议

1. **样本外测试**: 用历史数据优化的权重可能过拟合，应做滚动回测
2. **约束条件**: 实际中应添加单资产权重上下限（如 5%-40%）
3. **稳健估计**: 考虑使用收缩估计（shrinkage）替代样本协方差
4. **再平衡频率**: 定期（月度/季度）再平衡，避免频繁交易

## 下一步

- [高级教程：绩效归因与因子分析](04_高级_绩效归因与因子分析.md)
- 运行 `python examples/portfolio_optimization.py`
