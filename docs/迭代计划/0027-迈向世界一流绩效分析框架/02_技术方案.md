# 0027 - 技术方案

## 一、蒙特卡洛模拟模块设计

### 1.1 模块结构

```
fincore/simulation/
├── __init__.py          # 模块入口，导出公共API
├── base.py             # 基础模拟类和工具函数
├── paths.py            # 路径生成器（GBM、跳跃扩散等）
├── monte_carlo.py      # 蒙特卡洛模拟主类
├── bootstrap.py        # 自助法实现
├── scenarios.py        # 压力情景生成
└── utils.py           # 统计工具函数
```

### 1.2 API设计

```python
# fincore/simulation/monte_carlo.py
from typing import Optional, Union
import numpy as np
import pandas as pd

class MonteCarlo:
    """蒙特卡洛模拟引擎"""

    def __init__(
        self,
        returns: pd.Series,
        *,
        method: str = "gbm",  # gbm, jump_diffusion, heston
        rng: Optional[np.random.Generator] = None,
    ):
        self.returns = returns
        self.method = method
        self.rng = rng or np.random.default_rng()

    def simulate(
        self,
        n_paths: int = 1000,
        horizon: int = 252,
        *,
        drift: Optional[float] = None,
        volatility: Optional[float] = None,
    ) -> np.ndarray:
        """生成价格路径

        Returns
        -------
        np.ndarray, shape (n_paths, horizon)
            模拟的价格路径
        """
        pass

    def var(self, alpha: float = 0.05) -> float:
        """蒙特卡洛VaR"""
        pass

    def cvar(self, alpha: float = 0.05) -> float:
        """蒙特卡洛CVaR（Expected Shortfall）"""
        pass

    @staticmethod
    def bootstrap(
        returns: pd.Series,
        n_samples: int = 10000,
        statistic: str = "mean",
    ) -> np.ndarray:
        """自助法推断"""
        pass
```

### 1.3 实现要点

1. **几何布朗运动(GBM)**
```python
def geometric_brownian_motion(S0, mu, sigma, T, dt, n_paths):
    """GBM路径生成"""
    n_steps = int(T / dt)
    paths = np.zeros((n_paths, n_steps + 1))
    paths[:, 0] = S0

    for t in range(1, n_steps + 1):
        z = np.random.standard_normal(n_paths)
        paths[:, t] = paths[:, t-1] * np.exp(
            (mu - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * z
        )
    return paths
```

2. **置信区间计算**
```python
def bootstrap_ci(returns, n_samples=10000, alpha=0.05):
    """自助法置信区间"""
    boot_means = []
    for _ in range(n_samples):
        sample = np.random.choice(returns, size=len(returns), replace=True)
        boot_means.append(np.mean(sample))
    return np.percentile(boot_means, [alpha/2, 1-alpha/2])
```

---

## 二、投资组合优化模块设计

### 2.1 模块结构

```
fincore/optimization/
├── __init__.py
├── base.py             # 优化基类和约束
├── frontier.py         # 有效前沿计算
├── objectives.py       # 目标函数（夏普、风险平价等）
├── constraints.py      # 约束条件
└── solvers.py         # 求解器封装（cvxpy、scipy）
```

### 2.2 API设计

```python
# fincore/optimization/frontier.py
class EfficientFrontier:
    """有效前沿计算"""

    def __init__(
        self,
        returns: pd.DataFrame,
        frequency: int = 252,
    ):
        """
        Parameters
        ----------
        returns : pd.DataFrame
            各资产收益率，列名为资产
        frequency : int
            年化系数
        """
        self.returns = returns
        self.mean_returns = returns.mean() * frequency
        self.cov_matrix = returns.cov() * frequency

    def efficient_frontier(
        self,
        n_points: int = 50,
    ) -> pd.DataFrame:
        """计算有效前沿

        Returns
        -------
        pd.DataFrame
            包含 'return', 'volatility', 'sharpe' 列
        """
        pass

    def optimal_portfolio(
        self,
        method: str = "max_sharpe",  # max_sharpe, min_volatility, target_risk
        target_volatility: Optional[float] = None,
    ) -> dict:
        """最优组合权重

        Returns
        -------
        dict
            {'weights': pd.Series, 'metrics': dict}
        """
        pass

    @staticmethod
    def risk_parity(
        returns: pd.DataFrame,
    ) -> pd.Series:
        """风险平价组合"""
        pass

    @staticmethod
    def black_litterman(
        returns: pd.DataFrame,
        P: np.ndarray,       # 观点矩阵
        Q: np.ndarray,       # 观点收益
        tau: float = 0.05,  # 标量参数
    ) -> pd.Series:
        """Black-Litterman模型"""
        pass
```

### 2.3 CVXPY集成

```python
try:
    import cvxpy as cp

    def solve_max_sharpe(mu, cov, risk_free_rate=0):
        """使用CVXPY求解最大夏普比率组合"""
        n = len(mu)
        w = cp.Variable(n)

        # 目标函数：最大化夏普比率
        ret = mu @ w
        risk = cp.quad_form(w, cov)
        objective = cp.Maximize((ret - risk_free_rate) / cp.sqrt(risk))

        # 约束
        constraints = [
            cp.sum(w) == 1,  # 权重和为1
            w >= 0,           # 不允许做空
        ]

        problem = cp.Problem(objective, constraints)
        problem.solve()

        return w.value
except ImportError:
    # 退回到scipy优化
    pass
```

---

## 三、高级归因模块设计

### 3.1 模块结构

```
fincore/attribution/
├── __init__.py
├── brinson.py          # Brinson归因
├── fama_french.py     # Fama-French多因子
├── style_analysis.py   # 风格分析
└── timing.py          # 择时归因
```

### 3.2 Brinson归因

```python
# fincore/attribution/brinson.py
def brinson_attribution(
    portfolio_returns: pd.Series,
    benchmark_returns: pd.Series,
    portfolio_weights: pd.DataFrame,
    benchmark_weights: pd.DataFrame,
) -> dict:
    """Brinson归因分析

    将超额收益分解为:
    - 配置效应 (Allocation Effect)
    - 选股效应 (Selection Effect)
    - 交互效应 (Interaction Effect)

    Returns
    -------
    dict
        {
            'allocation': float,
            'selection': float,
            'interaction': float,
            'total': float,
        }
    """
    pass
```

### 3.3 Fama-French多因子

```python
# fincore/attribution/fama_french.py
class FamaFrenchModel:
    """Fama-French多因子模型"""

    # 支持的因子模型
    MODELS = {
        '3factor': ['MKT', 'SMB', 'HML'],
        '5factor': ['MKT', 'SMB', 'HML', 'RMW', 'CMA'],
        'momentum': ['MKT', 'SMB', 'HML', 'MOM'],
    }

    def __init__(self, model: str = '5factor'):
        self.model = model
        self.factors = self.MODELS[model]

    def fit(
        self,
        returns: pd.Series,
        factor_data: pd.DataFrame,
    ) -> dict:
        """拟合因子模型

        Returns
        -------
        dict
            {
                'alpha': float,
                'betas': pd.Series,
                'r_squared': float,
                'p_values': pd.Series,
            }
        """
        pass

    @staticmethod
    def fetch_factors(
        start: str,
        end: str,
        library: str = 'french',  # french, chinese
    ) -> pd.DataFrame:
        """获取因子数据（可选功能）"""
        pass
```

---

## 四、插件系统设计

### 4.1 插件注册表

```python
# fincore/plugin.py
from typing import Callable, Dict, List

class PluginRegistry:
    """插件注册表"""

    _metrics: Dict[str, Callable] = {}
    _hooks: Dict[str, List[Callable]] = {}
    _viz_backends: Dict[str, type] = {}

    @classmethod
    def register_metric(cls, name: str = None):
        """注册自定义指标"""
        def decorator(func: Callable) -> Callable:
            metric_name = name or func.__name__
            cls._metrics[metric_name] = func
            return func
        return decorator

    @classmethod
    def register_hook(cls, event: str):
        """注册事件钩子"""
        def decorator(func: Callable) -> Callable:
            if event not in cls._hooks:
                cls._hooks[event] = []
            cls._hooks[event].append(func)
            return func
        return decorator

    @classmethod
    def register_viz_backend(cls, name: str):
        """注册可视化后端"""
        def decorator(backend_class: type) -> type:
            cls._viz_backends[name] = backend_class
            return backend_class
        return decorator

    @classmethod
    def get_metric(cls, name: str) -> Callable:
        """获取注册的指标"""
        return cls._metrics.get(name)

    @classmethod
    def execute_hooks(cls, event: str, *args, **kwargs):
        """执行事件钩子"""
        for hook in cls._hooks.get(event, []):
            hook(*args, **kwargs)
```

### 4.2 使用示例

```python
# 用户自定义指标
from fincore import plugin

@plugin.register_metric("information_coefficient")
def information_coefficient(returns, factor_values):
    """信息系数"""
    import scipy.stats as stats
    return stats.spearmanr(factor_values, returns)[0]

# 注册钩子
@plugin.hook("pre_analysis")
def validate_returns(returns):
    """分析前验证"""
    if returns.isnull().any():
        raise ValueError("Returns contains NaN")
    return returns

# 注册自定义可视化后端
@plugin.register_viz_backend("plotly")
class PlotlyBackend:
    def plot_returns(self, cum_returns, **kwargs):
        import plotly.graph_objects as go
        fig = go.Figure()
        fig.add_trace(go.Scatter(y=cum_returns))
        return fig
```

---

## 五、依赖更新

### 5.1 新增可选依赖

```python
# pyproject.toml 更新
[project.optional-dependencies]
# 现有依赖
viz = ["matplotlib>=3.3", "seaborn>=0.11", "ipython>=7.0"]
bayesian = ["pymc>=5.0"]

# 新增依赖
optimization = ["cvxpy>=1.4", "scipy>=1.10"]
econometrics = ["arch>=6.0", "statsmodels>=0.14"]
interactive = ["plotly>=5.0", "dash>=2.0"]
data = ["yfinance>=0.2", "pandas-datareader>=0.10"]

# 组合
all = ["fincore[viz,bayesian,optimization,econometrics,interactive,data]"]
```

---

## 六、测试策略

### 6.1 测试金字塔

```
tests/test_simulation/        # 蒙特卡洛模块测试
├── test_monte_carlo.py
├── test_bootstrap.py
├── test_scenarios.py
└── fixtures/
    └── sample_paths.npy

tests/test_optimization/     # 优化模块测试
├── test_frontier.py
├── test_objectives.py
└── test_constraints.py

tests/test_attribution/      # 归因模块测试
├── test_brinson.py
├── test_fama_french.py
└── test_style_analysis.py

tests/test_plugin/          # 插件系统测试
└── test_registry.py
```

### 6.2 基准测试

```python
# tests/benchmarks/test_performance.py
import pytest
import numpy as np

@pytest.mark.benchmark
def test_monte_carlo_performance(benchmark):
    returns = np.random.normal(0.001, 0.02, 1000)
    result = benchmark(MonteCarlo.simulate, returns, n_paths=10000)
    assert result.shape == (10000, 252)

@pytest.mark.benchmark
def test_efficient_frontier_performance(benchmark):
    returns = pd.DataFrame(np.random.randn(252, 10))
    ef = EfficientFrontier(returns)
    result = benchmark(ef.efficient_frontier, n_points=50)
    assert len(result) == 50
```

---

## 七、发布计划

### 7.1 版本规划

| 版本 | 功能 | 发布时间 |
|-------|------|---------|
| v0.2.0 | 蒙特卡洛模拟 | 2周 |
| v0.3.0 | 投资组合优化 | 4周 |
| v0.4.0 | 高级归因 | 6周 |
| v0.5.0 | 插件系统 | 8周 |
| v1.0.0 | 世界一流水平 | 6个月 |

### 7.2 文档同步

- 更新README.md新功能说明
- 添加examples/高级示例
- API文档自动生成（Sphinx）
- 发布到PyPI和GitHub Release
