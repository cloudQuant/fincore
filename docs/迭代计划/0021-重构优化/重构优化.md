### 背景

fincore基于empyrical和pyfolio重构而来，本身已经进行了一定的优化和重构，但是系统架构可能还是存在一些问题。所以需要进一步研究，分析是否有更好的架构。

### 任务

基于行业最佳实践，对fincore进行重构，优化系统架构。

1. 分析研究，给出最佳的系统架构
2. 写出详细的重构计划
3. 重构代码
4. 测试
5. 发布

### 限制

1. 需要尽可能维持函数不变化，可以使用不同的类
2. 测试用例尽可能不要修改，测试用例的输入值和预期值不能变化。
3. 上个版本的empyrical.py使用了元类，项目中不允许使用元类，这次重构去掉元类的功能

---

## 一、当前架构分析

### 1.1 当前 empyrical.py 架构（0020版本，612行）

```
_EmpyricalMeta (元类)
  └─ __getattr__(cls, name) → 从 CLASSMETHOD_REGISTRY / STATIC_METHODS 解析
       └─ 缓存为 staticmethod

Empyrical (metaclass=_EmpyricalMeta)
  ├─ __init__()          → 初始化 returns, positions, factor_returns, factor_loadings
  ├─ __getattr__(name)   → 实例级别从 registry 解析（与元类重复逻辑）
  ├─ @_dual_method 方法  → ~50个手写方法，自动填充 returns/factor_returns
  ├─ @classmethod cagr() → 别名方法
  └─ 特殊方法            → perf_attrib, regression_annual_return, _groupby_consecutive
```

### 1.2 问题

| 问题 | 说明 |
|------|------|
| **元类** | `_EmpyricalMeta` 增加认知复杂度，调试困难，IDE支持差 |
| **双重 `__getattr__`** | 元类和实例各有一个 `__getattr__`，逻辑重复 |
| **`_dual_method` 描述符** | 自定义描述符复杂度高，缓存逻辑不直观 |

### 1.3 测试访问模式

测试代码有两种访问方式：
1. **类级别**: `Empyrical.sharpe_ratio(returns)` — 直接调用
2. **实例级别**: `emp = Empyrical(); getattr(emp, 'sharpe_ratio')` — 通过 `ReturnTypeEmpyricalProxy` 代理

两种方式都必须返回相同的底层函数（不绑定 self）。

---

## 二、目标架构（无元类）

### 2.1 核心思路：`_LazyMethod` 描述符 + 类装饰器

用 Python 标准的 **非数据描述符**（non-data descriptor）替代元类：

```
_LazyMethod (非数据描述符)
  └─ __get__(obj, objtype) → 首次访问时解析函数
       └─ setattr(owner, name, staticmethod(func))  # 自替换，后续零开销

@_populate_from_registry   (类装饰器)
  └─ 遍历 CLASSMETHOD_REGISTRY / STATIC_METHODS
       └─ setattr(cls, name, _LazyMethod(...))

Empyrical   (普通类，无元类)
  ├─ __init__()
  ├─ __getattr__(name)   → 安全回退（处理子类/动态访问边缘情况）
  ├─ @_dual_method 方法  → 保留不变（需要显式签名和实例状态自动填充）
  └─ 特殊方法            → 保留不变
```

### 2.2 工作原理

```python
class _LazyMethod:
    """非数据描述符，首次访问时解析底层函数并自替换为 staticmethod。"""
    def __get__(self, obj, objtype=None):
        func = getattr(_resolve_module(self.mod_alias), self.func_name)
        setattr(self._owner, self.attr_name, staticmethod(func))
        return func
```

- **类级别访问** `Empyrical.sharpe_ratio` → `_LazyMethod.__get__(None, Empyrical)` → 解析 → 自替换 → 返回函数
- **实例级别访问** `emp.sharpe_ratio` → `_LazyMethod.__get__(emp, Empyrical)` → 同上
- **后续访问** → 找到 `staticmethod(func)` → 直接返回原函数，零开销

### 2.3 优势

| 对比项 | 元类方案 | 描述符+装饰器方案 |
|--------|---------|-----------------|
| 复杂度 | 高（元类 + 双重 __getattr__）| 低（标准描述符协议）|
| IDE支持 | 差（元类动态属性不可见）| 好（描述符在类字典中可见）|
| 调试 | 难（元类 __getattr__ 拦截所有未知属性）| 易（描述符明确可追踪）|
| 性能 | 首次访问后零开销 | 首次访问后零开销（相同）|
| 子类继承 | 通过元类继承（隐式）| 通过 MRO 正常继承（显式）|

---

## 三、重构计划

### 步骤 S1：替换元类为描述符+装饰器

**改动范围**: 仅 `fincore/empyrical.py`

1. 新增 `_LazyMethod` 非数据描述符类
2. 新增 `_populate_from_registry` 类装饰器
3. 删除 `_EmpyricalMeta` 元类
4. 修改 `class Empyrical` 定义：移除 `metaclass=_EmpyricalMeta`，添加 `@_populate_from_registry`
5. 简化 `Empyrical.__getattr__`（仅作安全回退）
6. 更新模块 docstring

**不变**: `_registry.py`、`_dual_method`、所有 `@_dual_method` 方法、特殊方法、`__init__.py`

**测试基线**: 1299 passed, 0 failed

---

## 四、执行结果

### S1 执行完成

**改动文件**: `fincore/empyrical.py`（1处文件，4处编辑）

| 改动 | 说明 |
|------|------|
| 删除 `_EmpyricalMeta` 元类 | 30行 → 0行 |
| 新增 `_LazyMethod` 描述符 | 非数据描述符，21行，`__slots__` 优化 |
| 新增 `@_populate_from_registry` | 类装饰器，7行 |
| 修改 `class Empyrical` 定义 | `metaclass=_EmpyricalMeta` → `@_populate_from_registry` |
| 更新 docstring | 模块级 + 类级 + `__getattr__` 级 |

### 验证结果

```
pytest tests/ -n 8: 1299 passed, 0 failed (25.44s)

type(Empyrical):            <class 'type'>  (无元类)
Has _EmpyricalMeta:         False
import fincore:             ~0.054s
import fincore.tearsheets:  ~0.0004s
Empyrical.sharpe_ratio:     首次 ~1.16s (含模块加载), 缓存后 ~0.000001s
emp.value_at_risk:          ~0.000005s (实例访问)
```

### 架构对比

| 项目 | 0020版本（元类） | 0021版本（描述符+装饰器） |
|------|----------------|----------------------|
| `type(Empyrical)` | `<class '_EmpyricalMeta'>` | `<class 'type'>` |
| 元类 | `_EmpyricalMeta` (30行) | 无 |
| 动态方法解析 | 元类 `__getattr__` + 实例 `__getattr__` | `_LazyMethod` 描述符 + 实例 `__getattr__`(安全回退) |
| 测试 | 1299 passed | 1299 passed |
| 函数签名 | 不变 | 不变 |