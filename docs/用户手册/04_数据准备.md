# 数据准备

## 核心数据类型

### 1. 收益率序列 (returns)

**格式**: `pd.Series`，索引为 `pd.DatetimeIndex`

```python
import pandas as pd
import numpy as np

# 标准格式
dates = pd.date_range("2020-01-01", periods=252, freq="B", tz="UTC")
returns = pd.Series(np.random.normal(0.0005, 0.01, 252), index=dates, name="strategy")
```

**要求**:
- 简单收益率（非累计），即 `(P_t - P_{t-1}) / P_{t-1}`
- 索引为 `DatetimeIndex`（建议带时区，如 UTC）
- 不包含 NaN（或已处理）

**从净值转换**:

```python
# 净值序列 -> 日收益率
nav = pd.Series([1.0, 1.01, 0.99, 1.02], index=dates[:4])
returns = nav.pct_change().dropna()
```

### 2. 基准收益率 (factor_returns / benchmark)

与 `returns` 格式相同，索引需对齐：

```python
benchmark = pd.Series(np.random.normal(0.0003, 0.008, 252), index=dates, name="benchmark")
```

### 3. 持仓数据 (positions)

**格式**: `pd.DataFrame`，索引为 `DatetimeIndex`，每列为一个资产 + `cash` 列

```python
positions = pd.DataFrame({
    "AAPL": [50000, 52000, 48000],
    "MSFT": [30000, 31000, 29000],
    "cash": [20000, 17000, 23000],
}, index=dates[:3])
```

**要求**:
- 值为每日持仓的市值（金额）
- 必须包含 `cash` 列
- 索引与 `returns` 对齐

### 4. 交易数据 (transactions)

**格式**: `pd.DataFrame`，索引为 `DatetimeIndex`

```python
transactions = pd.DataFrame({
    "amount": [100, -50, 200],
    "price": [150.0, 155.0, 148.0],
    "symbol": ["AAPL", "AAPL", "MSFT"],
}, index=pd.DatetimeIndex(["2020-01-02", "2020-01-05", "2020-01-06"], tz="UTC"))
```

**必需列**:

| 列名 | 类型 | 说明 |
|------|------|------|
| `amount` | float | 交易数量（正=买入，负=卖出） |
| `price` | float | 成交价格 |
| `symbol` | str | 资产代码 |

## 从回测日志加载数据

fincore 的 `examples/011_abberation/` 展示了从策略回测日志加载数据的完整流程：

```python
import pandas as pd

# 1. 从净值日志加载收益率
value_df = pd.read_csv("value.log", sep="\t", usecols=["dt", "value", "cash"])
value_df["dt"] = pd.to_datetime(value_df["dt"])
daily_value = value_df.groupby(value_df["dt"].dt.date).last()
daily_value.index = pd.to_datetime(daily_value.index)
returns = daily_value["value"].pct_change().dropna()
returns.index = returns.index.tz_localize("UTC")

# 2. 从持仓日志加载持仓
pos_df = pd.read_csv("position.log", sep="\t", usecols=["dt", "data_name", "size", "price"])
pos_df["dt"] = pd.to_datetime(pos_df["dt"])
positions = pd.DataFrame(index=daily_value.index)
for asset in pos_df["data_name"].unique():
    ap = pos_df[pos_df["data_name"] == asset]
    ad = ap.groupby(ap["dt"].dt.date).last()
    ad.index = pd.to_datetime(ad.index)
    positions[asset] = ad["size"] * ad["price"]
positions["cash"] = daily_value["cash"]
positions = positions.fillna(0)
positions.index = positions.index.tz_localize("UTC")

# 3. 从订单日志加载交易
order_df = pd.read_csv("order.log", sep="\t")
completed = order_df[order_df["status"] == "Completed"].copy()
completed["dt"] = pd.to_datetime(completed["dt"])
transactions = pd.DataFrame({
    "amount": completed["size"].values,
    "price": completed["executed_price"].values,
    "symbol": completed["data_name"].values,
}, index=pd.DatetimeIndex(completed["dt"].values).tz_localize("UTC"))
```

## 时区处理

- 建议统一使用 UTC 时区
- 混合时区数据在对齐时可能产生问题
- 使用 `tz_localize("UTC")` 或 `tz_convert("UTC")` 统一时区

```python
# 无时区 -> UTC
returns.index = returns.index.tz_localize("UTC")

# 其他时区 -> UTC
returns.index = returns.index.tz_convert("UTC")
```

## 数据质量检查

```python
# 检查缺失值
print(f"NaN count: {returns.isna().sum()}")

# 检查极端值
print(f"Min: {returns.min():.4f}, Max: {returns.max():.4f}")

# 检查索引连续性
gaps = returns.index.to_series().diff().dt.days
print(f"Max gap: {gaps.max()} days")
```
